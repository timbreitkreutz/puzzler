<!DOCTYPE html>
<html>
<head>
    <title>
        Puzzler
    </title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro' rel='stylesheet' type='text/css'>
    <style type="text/css">
        canvas { border: 1px solid black; }
        body { font-family: 'Source Sans Pro', sans-serif; }
    </style>
</head>
<body>
    <p>
        This page demonstrates using the Canvas from raw javascript without using jQuery or other 
        libraries.
        To play the puzzle, click on a square next to the blank square.  When you solve the puzzle
        the top right corner will appear.
    </p>
    <canvas width="604" height="604" id="puzzle">
        <p>
            Please try a newer browser! Thanks.
        </p>
    </canvas>
    <p>
        <input id="inputUrl" type="text" size="80" value="Please enter a URL to change the picture">
    </p>
    <script type="text/javascript">

(function () {
    "use strict";

    //  Tim Breitkreutz/2014
    //
    //  Available under creative commons share-alike licence by
    //  Software Brewmasters Incorporated

    var puzzle, shuffle, emptyTile, tiles, pictureUrl;

    shuffle = function () {
        var ii, neighbours;

        // for (ii = 0; ii < tiles.length * 5; ii += 1) {
            neighbours = emptyTile.neighbours();

            emptyTile.swap(neighbours[Math.floor(Math.random() * neighbours.length)]);
        // }
    };

    var tileFactory = function(tile, size, border) {
        var tileSize = size + border;

        var draw = function () {
            if (this.empty) {
                this.ctx.fillRect(this.col * (tileSize),
                                  this.row * (tileSize),
                                  size, size);
            } else {
                this.ctx.drawImage(this.img,
                                   this.imageCol * this.imageSize,
                                   this.imageRow * this.imageSize,
                                   this.imageSize, this.imageSize,
                                   this.col * (tileSize),
                                   this.row * (tileSize),
                                   size, size);
            }
        };

        var contains = function (xx, yy) {
            if (this.empty) {
                return false;
            }
            return this.col      * (tileSize) < xx &&
                  (this.col + 1) * (tileSize) > xx &&
                   this.row      * (tileSize) < yy &&
                  (this.row + 1) * (tileSize) > yy;
        };

        var neighbour = function (tile) {
            return Math.abs(this.col - tile.col) + Math.abs(this.row - tile.row) === 1;
        };

        var emptyNeighbour = function () {
            return this.neighbour(emptyTile);
        };

        var neighbours = function () {
            var that, result = [];
            that = this;
            tiles.forEach(function (tile) {
                if (that.neighbour(tile)) {
                    result.push(tile);
                }
            });
            return result;
        };

        var solved = function () {
            return this.col === this.imageCol && this.row === this.imageRow;
        };

        var swap = function (that) {
            var row, col;
            if (!this.neighbour(that)) {
                //console.log("illegal swap");
                return;
            }
            row = this.row;
            col = this.col;
            this.row = that.row;
            this.col = that.col;
            that.row = row;
            that.col = col;
        };

        if (tile) {
            return Object.create(tile);
        } else {
            var newTile =  {
                size: size,
                border: border,
                draw: draw,
                contains: contains,
                neighbour: neighbour,
                emptyNeighbour: emptyNeighbour,
                neighbours: neighbours,
                solved: solved,
                swap: swap
            };
            // State
            (function() {
                var theRow = 0, 
                    theCol = 0;
                newTile.position = function() {
                    return {row: theRow, col: theCol};
                };
                newTile.setPosition = function(row, col) {
                    theRow = row;
                    theCol = col;
                };
            }());
            return newTile;
        }
    }

    puzzle = function (count, size, border, imageUrl) {
        var canvas, tile, move, puzzleSolved;

        canvas = document.getElementById('puzzle');

        tile = tileFactory(null, size, border);

        if (canvas.getContext) {
            tile.ctx = canvas.getContext('2d');
            tile.ctx.fillStyle = "rgb(255, 255, 255)";

            tile.img = new Image();
            tile.img.src = imageUrl;

            tiles = [];
            tile.img.onload = function () {
                var ii, jj;
                if (tile.img.height > tile.img.width) {
                    tile.imageSize = tile.img.width / count;
                } else {
                    tile.imageSize = tile.img.height / count;
                }
                for (ii = 0; ii < count; ii += 1) {
                    for (jj = 0; jj < count; jj += 1) {
                        tile = tileFactory(tile);
                        tile.row = ii;
                        tile.col = jj;
                        tile.imageRow = ii;
                        tile.imageCol = jj;
                        tile.empty = (ii === 0 && jj === count - 1);
                        tiles.push(tile);
                        if (tile.empty) {
                            emptyTile = tile;
                        }
                    }
                }
                while (puzzleSolved()) {
                    shuffle();
                }
                tiles.forEach(function (tile) {
                    tile.draw();
                });
            };
        }
        move = function (tile, emptyTile) {
            tile.swap(emptyTile);
            emptyTile.draw();
            tile.draw();
        };
        puzzleSolved = function () {
            var ii;

            for(ii = 0; ii < tiles.length; ii += 1) {
                if (tiles[ii].row != tiles[ii].imageRow ||
                    tiles[ii].col != tiles[ii].imageCol) {
                    return false;
                }
            }
            return true;
        };
        canvas.onclick = function (ev) {
            if (puzzleSolved()) {
                return;
            }
            tiles.forEach(function (tile) {
                var x, y;

                // chrome/safari vs firefox
                x = ev.x || ev.clientX;
                y = ev.y || ev.clientY;

                if (tile.contains(x, y) && tile.emptyNeighbour()) {
                    move(tile, emptyTile);
                    if (puzzleSolved()) {
                        emptyTile.empty = false;
                        emptyTile.draw();
                    }
                }
            });
        };
    };
    //pictureUrl = "http://ia.media-imdb.com/images/M/MV5BNDM1NzkzMjQ4NF5BMl5BanBnXkFtZTcwMDE3Nzk3Mg@@._V1_SX640_SY720_.jpg";
    pictureUrl = "http://www.tumblr18.com/t18/2013/10/Puppies-in-a-basket.jpeg";

    window.onload = function () {
        var inputUrl, rows, tileSize, border, firstFocus, reload;
        rows = 3;
        tileSize = 200;
        border = 2;
        firstFocus = true;

        puzzle(rows, tileSize, border, pictureUrl);
        inputUrl = document.getElementById('inputUrl');
        inputUrl.onfocus = function () {
            if (firstFocus) {
                this.value = "";
                firstFocus = false;
            }
        };
        reload = function (ev) {
            if (ev.type === "keyup" && ev.which !== 13) {
                return;
            }
            var img = new Image();
            img.src = this.value;

            img.onload = function () {
                if (img.height > 0) {
                    puzzle(rows, tileSize, border, inputUrl.value);
                }
            };
        };
        inputUrl.onblur = reload;
        inputUrl.onkeyup = reload;
    };
}());
    </script>
</body>
</html>
