<!DOCTYPE html>
<html>
<head>
  <title>
    Puzzler
  </title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <style type="text/css">
    canvas { border: 1px solid black; }
  </style>
</head>
<body>
  <canvas width="604" height="604" id="puzzle">
    <p>
      Please try a newer browser!  Thanks.
    </p>
  </canvas>
  <script type="text/javascript">
    (function () {
      "use strict";

      //  Tim Breitkreutz/2014
      //
      //  Available under creative commons share-alike licence by
      //  Software Brewmasters Incorporated

      var puzzle, shuffle, emptyTile, tiles, pictureUrl;

      shuffle = function () {
        var ii, neighbours;
    
        //for (ii = 0; ii < tiles.length * 1; ii += 1) {
        for (ii = 0; ii < 3; ii += 1) {
          neighbours = emptyTile.neighbours();

          emptyTile.swap(neighbours[Math.floor(Math.random() * neighbours.length)]);
        }
      };

      puzzle = function (count, size, border, imageUrl) {
        var canvas, tile, move, puzzleSolved;
      
        canvas = document.getElementById('puzzle');
        tile = {
          size: size,
          border: border,
          draw: function () {
            if (this.empty) {
              this.ctx.fillRect(this.col * (this.size + this.border), 
                     this.row * (this.size + this.border),
                     this.size, this.size);
            } else {
              this.ctx.drawImage(this.img,
                                 this.imageCol * this.imageSize, 
                                 this.imageRow * this.imageSize, 
                                 this.imageSize, this.imageSize, 
                                 this.col * (this.size + this.border),
                                 this.row * (this.size + this.border), 
                                 this.size, this.size);
            }
          },
          contains: function (xx, yy) {
            if (this.empty) {
              return false;
            }
            return this.col * (this.size + this.border) < xx && 
                  (this.col + 1) * (this.size + this.border) > xx &&
                  this.row * (this.size + this.border) < yy && 
                  (this.row + 1) * (this.size + this.border) > yy;
          },
          neighbour: function (tile) {
            return Math.abs(this.col - tile.col) + Math.abs(this.row - tile.row) === 1;
          },
          emptyNeighbour: function () {
            return this.neighbour(emptyTile);
          },
          neighbours: function () {
            var that, result = [];
            that = this;
            tiles.forEach(function (tile) {
              if (that.neighbour(tile)) {
                result.push(tile);
              }
            });
            return result;
          },
          solved: function () {
            return this.col === this.imageCol && this.row === this.imageRow;
          },
          swap: function(that) {
            var row, col;
            if (!this.neighbour(that)) {
              console.log("illegal swap");
              return;
            }
            row = this.row;
            col = this.col;
            this.row = that.row;
            this.col = that.col;
            that.row = row;
            that.col = col; 
          }
        };
        if (canvas.getContext) {
          tile.ctx = canvas.getContext('2d');
          tile.ctx.fillStyle = "rgb(255, 255, 255)";

          tile.img = new Image();
          tile.img.src = imageUrl;
          
          tiles = []; 
          tile.img.onload = function () {
            var ii, jj;
            if (tile.img.height > tile.img.width) {
              tile.imageSize = tile.img.width / count;
            } else {
              tile.imageSize = tile.img.height / count;
            }
            for (ii = 0; ii < count; ii += 1) {
              for (jj = 0; jj < count; jj += 1) {
                tile = Object.create(tile);
                tile.row = ii;
                tile.col = jj;
                tile.imageRow = ii;
                tile.imageCol = jj;
                tile.empty = (ii === 0 && jj === count - 1);
                tiles.push(tile);
                if (tile.empty) {
                  emptyTile = tile;
                }
              }
            }
            while (puzzleSolved()) {
              shuffle();
            }
            tiles.forEach(function (tile) {
              tile.draw();
            });
          };
        }
        move = function (tile, emptyTile) {
          tile.swap(emptyTile);
          emptyTile.draw();
          tile.draw();
        };
        puzzleSolved = function () {
          var solved = true;
          tiles.forEach(function (tile) {
            if (!tile.solved()) { 
              solved = false;
            }
          });
          return solved;
        };
        canvas.onclick = function(ev) {
          if (puzzleSolved()) {
            return;
          }
          tiles.forEach(function (tile) {
            var x, y;

            // chrome/safari vs firefox
            x = ev.x || ev.clientX;
            y = ev.y || ev.clientY;
          
            if (tile.contains(x, y) && tile.emptyNeighbour()) {
              move(tile, emptyTile);
              if (puzzleSolved()) {
                emptyTile.empty = false;
                emptyTile.draw();
              }
            }
          });
        };
      };
      //pictureUrl = "http://ia.media-imdb.com/images/M/MV5BNDM1NzkzMjQ4NF5BMl5BanBnXkFtZTcwMDE3Nzk3Mg@@._V1_SX640_SY720_.jpg";
      pictureUrl = "http://www.tumblr18.com/t18/2013/10/Puppies-in-a-basket.jpeg";

      window.onload = function() { 
        puzzle(3, 200, 2, pictureUrl); 
      };
    }());
  </script>
</body>
</html>
