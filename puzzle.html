<!DOCTYPE html>
<html>
<head>
    <title>
        Puzzler
    </title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro' rel='stylesheet' type='text/css'>
    <style type="text/css">
        canvas { border: 1px solid black; }
        body { font-family: 'Source Sans Pro', sans-serif; }
    </style>
</head>
<body>
    <p>
        This page demonstrates using the Canvas from raw javascript without using jQuery or other 
        libraries.
        To play the puzzle, click on a square next to the blank square.  When you solve the puzzle
        the top right corner will appear.
    </p>
    <canvas width="604" height="604" id="puzzle">
        <p>
            Please try a newer browser! Thanks.
        </p>
    </canvas>
    <p>
        <input id="inputUrl" type="text" size="80" value="Please enter a URL to change the picture">
    </p>
    <script type="text/javascript">
        (function () {
            "use strict";

            //  Tim Breitkreutz/2014
            //
            //  Available under creative commons share-alike licence by
            //  Software Brewmasters Incorporated

            var puzzle, shuffle, emptyTile, tiles, pictureUrl;

            shuffle = function () {
                var ii, neighbours;

                for (ii = 0; ii < 2; ii += 1) { //tiles.length * 2; ii += 1) {
                    neighbours = emptyTile.neighbours();

                    emptyTile.swap(neighbours[Math.floor(Math.random() * neighbours.length)]);
                }
            };

            puzzle = function (count, size, border, imageUrl) {
                var canvas, tile, move, puzzleSolved;

                canvas = document.getElementById('puzzle');
                tile = {
                    size: size,
                    border: border,
                    draw: function () {
                        if (this.empty) {
                            this.ctx.fillRect(this.col * (this.size + this.border),
                                              this.row * (this.size + this.border),
                                              this.size, this.size);
                        } else {
                            this.ctx.drawImage(this.img,
                                               this.imageCol * this.imageSize,
                                               this.imageRow * this.imageSize,
                                               this.imageSize, this.imageSize,
                                               this.col * (this.size + this.border),
                                               this.row * (this.size + this.border),
                                               this.size, this.size);
                        }
                    },
                    contains: function (xx, yy) {
                        if (this.empty) {
                            return false;
                        }
                        return this.col      * (this.size + this.border) < xx &&
                              (this.col + 1) * (this.size + this.border) > xx &&
                               this.row      * (this.size + this.border) < yy &&
                              (this.row + 1) * (this.size + this.border) > yy;
                    },
                    neighbour: function (tile) {
                        return Math.abs(this.col - tile.col) + Math.abs(this.row - tile.row) === 1;
                    },
                    emptyNeighbour: function () {
                        return this.neighbour(emptyTile);
                    },
                    neighbours: function () {
                        var that, result = [];
                        that = this;
                        tiles.forEach(function (tile) {
                            if (that.neighbour(tile)) {
                                result.push(tile);
                            }
                        });
                        return result;
                    },
                    solved: function () {
                        return this.col === this.imageCol && this.row === this.imageRow;
                    },
                    swap: function (that) {
                        var row, col;
                        if (!this.neighbour(that)) {
                            //console.log("illegal swap");
                            return;
                        }
                        row = this.row;
                        col = this.col;
                        this.row = that.row;
                        this.col = that.col;
                        that.row = row;
                        that.col = col;
                    }
                };
                if (canvas.getContext) {
                    tile.ctx = canvas.getContext('2d');
                    tile.ctx.fillStyle = "rgb(255, 255, 255)";

                    tile.img = new Image();
                    tile.img.src = imageUrl;

                    tiles = [];
                    tile.img.onload = function () {
                        var ii, jj;
                        if (tile.img.height > tile.img.width) {
                            tile.imageSize = tile.img.width / count;
                        } else {
                            tile.imageSize = tile.img.height / count;
                        }
                        for (ii = 0; ii < count; ii += 1) {
                            for (jj = 0; jj < count; jj += 1) {
                                tile = Object.create(tile);
                                tile.row = ii;
                                tile.col = jj;
                                tile.imageRow = ii;
                                tile.imageCol = jj;
                                tile.empty = (ii === 0 && jj === count - 1);
                                tiles.push(tile);
                                if (tile.empty) {
                                    emptyTile = tile;
                                }
                            }
                        }
                        while (puzzleSolved()) {
                            shuffle();
                        }
                        tiles.forEach(function (tile) {
                            tile.draw();
                        });
                    };
                }
                move = function (tile, emptyTile) {
                    tile.swap(emptyTile);
                    emptyTile.draw();
                    tile.draw();
                };
                puzzleSolved = function () {
                    var solved = true;
                    tiles.forEach(function (tile) {
                        if (!tile.solved()) {
                            solved = false;
                        }
                    });
                    return solved;
                };
                canvas.onclick = function (ev) {
                    if (puzzleSolved()) {
                        return;
                    }
                    tiles.forEach(function (tile) {
                        var x, y;

                        // chrome/safari vs firefox
                        x = ev.x || ev.clientX;
                        y = ev.y || ev.clientY;

                        if (tile.contains(x, y) && tile.emptyNeighbour()) {
                            move(tile, emptyTile);
                            if (puzzleSolved()) {
                                emptyTile.empty = false;
                                emptyTile.draw();
                            }
                        }
                    });
                };
            };
            //pictureUrl = "http://ia.media-imdb.com/images/M/MV5BNDM1NzkzMjQ4NF5BMl5BanBnXkFtZTcwMDE3Nzk3Mg@@._V1_SX640_SY720_.jpg";
            pictureUrl = "http://www.tumblr18.com/t18/2013/10/Puppies-in-a-basket.jpeg";

            window.onload = function () {
                var inputUrl, rows, tileSize, border, firstFocus, reload;
                rows = 3;
                tileSize = 200;
                border = 2;
                firstFocus = true;

                puzzle(rows, tileSize, border, pictureUrl);
                inputUrl = document.getElementById('inputUrl');
                inputUrl.onfocus = function () {
                    if (firstFocus) {
                        this.value = "";
                        firstFocus = false;
                    }
                };
                reload = function (ev) {
                    if (ev.type === "keyup" && ev.which !== 13) {
                        return;
                    }
                    var img = new Image();
                    img.src = this.value;

                    img.onload = function () {
                        if (img.height > 0) {
                            puzzle(rows, tileSize, border, inputUrl.value);
                        }
                    };
                };
                inputUrl.onblur = reload;
                inputUrl.onkeyup = reload;
            };
        }());
    </script>
</body>
</html>
